#include<iostream>
using namespace std;

class Weapon
{
	int damage;	//Ќаносимый урон
	int size;
public:
	Weapon(int damage, int size) :damage(damage), size(size)
	{
	}
	virtual ~Weapon()
	{
	}
	virtual void apply() = 0;	//чисто виртуальный метод („исто виртуальна€ функци€)

	virtual void info()
	{
		cout << "Damage:\t" << damage << endl;
		cout << "Size:\t" << size << endl;
	}
};

class ColdArms :public Weapon
{
public:
	ColdArms(int damage, int size) : Weapon(damage, size){}
	~ColdArms(){}
	//Ётот класс Ќе определ€ет чисто виртуальный метод apply а просто наследует его чистую виртуальность и следовательно этот клас так же €вл€етс€ абстрактным. 
};

class Knife : public ColdArms
{
public:
	Knife(int damage, int size):ColdArms(damage,size){}
	~Knife(){}
	// Ётот класс уже €вл€етс€ конкретным по скольку он реализует чисто виртуальную функцию apply()
	void apply()
	{
		cout << "„истить картошку, резать €блоки" << endl;
	}
	void info()
	{
		Weapon::info();
		apply();
	}
};

class Machete :public ColdArms
{
public:
	Machete(int damage, int size):ColdArms(damage,size){}
	~Machete()	{}
	void apply()
	{
		cout << "ќтлично рубит сахарный тросник, так же очень удобен дл€ стрижки деревьев" << endl;
	}
	void info()
	{
		Weapon::info();
		apply();
	}
};

void main()
{
	setlocale(LC_ALL, "");
	//Weapon w(20,5);    w.info();  //—оздать экземпл€р этого класса нельз€ поскольку он тоже €вл€етс€ абстрактным

	//ColdArms ca(20, 5);	//—оздать экземпл€р этого класса нельз€ поскольку он тоже €вл€етс€ абстрактным

	Knife kn(20, 5);		kn.info();
	Machete m(50, 25);		m.info();


}

//јбстрактный базовый класс
/*
	јбстрактным называетс€ класс не имеющий экземпл€ров по скольку они не могут существовать например растение, животное, оружие, транспорт это всЄ абстрактные пон€ти€ а объекты €вл€ютс€ экземпл€рами каких то конкретных классов например дуб, кот, пистолет или автомобиль
	јбстрактные классы лишь обобщают некоторые свойства других классов и таким образом предназначенны лишь дл€ класификации объектов и дл€ создани€ классовых иерархий
	ƒл€ того чтобы сделать класс абстрактным в нЄм нужно объ€вить хот€ бы один чисто виртуальный метод.
	„исто виртуальным называетс€ метод не имеющий определение.
	„исто виртуальный метод об€зательно должен быть определЄн в дочернем классе в противном случае дочерний класс унаследует чистую виртуальность и тоже будет абстрактным.

*/